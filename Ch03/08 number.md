### Number 类型

`Number`类型应该是`ECMAScript`中最令人关注的数据类型了，这种类型使用`IEEE754`格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。  

为支持各种数值类型，ECMA-262定义了不同的数值字面量格式。  

#### 最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：  

	var intNum = 55;   // 整数

除了以十进制表示外，整数还可以通过**八进制**(以8为基数)或**十六进制**(以16为基数)的字面值来表示。  

#### 其中，八进制字面值的**第一位必须是零(0)**，然后是八进制数字序列(0-7)。  

**如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析**。请看下面的例子：  

	var octalNum1 = 070; // 八进制的56
    var octalNum2 = 079; // **无效的八进制数值 -- 解析为79**
    var octalNum3 = 08;  // 无效的八进制数值 -- 解析为 8

**八进制字面量在严格模式下是无效的**，会导致支持的JavaScript引擎抛出错误。

#### 十六进制字面值的前面必须是 0x，后面跟任何十六进制数字 (0-9 及 A-F) 。  

其中，**字母 A-F 可以大写，也可以小写**。如下面的例子所示：  

	var hexNum1 = 0xA;            // 十六进制的 10
    var hexNum2 = 0x1f;           // 十六进制的 31

**在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。**

鉴于JavaScript中保存数值的方式，可以保存正零(+0)和负零(-0)。正零和负零被认为相等。


#### 浮点数值

所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。  

虽然小数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数的几个例子：  

	var floatNum1 = 1.1;
    var floatNum2 = 0.1;
    var floatNum3 = .1;  // 有效，但不推荐

由于**保存浮点数值需要的内存空间是保存整数值的两倍**。因此ECMASCript会不失时机地将浮点数值转换为整数值。  

显然，**如果小数点后面没有跟任何数字，那么这个数值就可以作为整数来保存**。  

同样地，如果浮点数值本身表示的就是一个整数(如1.0)，那么该值也会被转换为整数，如下面的例子所示：  

	var floatNum1 = 1. ;  // 小数点后面没有数字 -- 解析为1 
    var floatNum2 = 10.0; // 整数 -- 解析为10

**对于那些极大或极小的数值，可以用 e 表示法(即科学计数法) 表示的浮点数值表示**。  

**用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂**。   

ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值 (可以是整数也可以是浮点数)，  
中间是一个大写或小写的字母 E，后面是10的幂中的指数，该幂值将用来与前面的数相乘。  

下面是一个使用 e 表示法表示数值的例子：  
     
	var floatNum = 3.125e7;    // 等于 31250000

在这个例子中，使用 e 表示法表示的变量 `floatNum` 的形式虽然简洁，但它的实际值则是 31250000 。  
在此，e 表示法的实际含义就是 "3.125乘以10的7次幂"。

**也可以使用e表示法表示极小的数值**，如 0.00000000000000003 ，  
这个数值可以使用更简洁的 3e-17 表示。  

在默认情况下，ECMAScript 会将那些小数点后面带有6个零以上的浮点数值转换为以 e 表示法表示的数值  
(例如， 0.0000003 会被转换成 3e-7) 。  

浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数。  

例如， 0.1 加 0.2 的结果不是 0.3 而是 0.30000000000000004 。  
这个小小的舍入误差会导致无法测试特定的浮点数值。例如：   

	if (a + b == 0.3) { // 不要做这样的测试！
    	alert("You got 0.3");
    }

在这个例子中，我们测试的是两个数的和是不是0.3 。  
如果这两个数是 0.05 和 0.25 ，或者是 0.15和0.15都不会有问题。  
而如前所述，如果这两个数是 0.1 和 0.2 ，那么测试将无法通过。  
因此，**永远不要测试某个特定的浮点数值**。  

关于浮点数值计算会产生舍入误差的问题，有一点需要明确：  
这是使用基于 IEEE754 数值的浮点计算的通病，ECMASCript 并非独此一家；  
其他使用相同数值格式的语言也存在这个问题。

#### 数值范围

由于内存的限制，ECMAScript 并不能保存世界上所有的数值。  
ECMAScript 能够表示的最小数值存在 Number.MIN_VALUE 中 -- 在大多数浏览器中，这个值是 5e-324 ；  
能够表示的最大数值保存在 Number.MAX_VALUE 中 -- 在大多数浏览器中，  
这个值是 1.7976931348623157e+308。  
**如果某次计算的结果超出了JavaScript数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值**。  
具体来说，如果这个数值是负数，则会转换成 -Infinity (负无穷) ，    
如果这个数值是正数，则会被转换成 Infinity (正无穷)。  

如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将**无法继续参与下一次的计算**。  
因为 Infinity 不是能够参与计算的数值。  

**要想确定一个数值是不是有穷的** (换句话说，是不是位于最小和最大的数值之间)，   
可以使用  `isFinite()` 函数。  
这个函数在参数位于最小与最大数值之间时会返回 true，如下面的例子所示：  

	var result = Number.MAX_VALUE + Number.MAX_VALUE;
    alert(isFinite(result));    // false

尽管在计算中很少出现某些值超出表示范围的情况，  
但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。  

访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以得到负和正 Infinity 的值。  
可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。  

#### NaN

NaN，即非数值 (Not a Number) 是一个特殊的数值，  
这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。  

例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。  
但在ECMAScript中，任何数值除以0会返回 NaN（Infinity），因此不会影响其他代码的执行。  
     
     
**NaN本身有两个非同寻常的特点**。
  
首先，任何涉及NaN的操作(例如 NaN/10) 都会返回 NaN ，这个特点在多步计算中有可能导致问题。  

其次，NaN与任何值都不相等，包括 NaN 本身。  
例如，下面的代码会返回 false ：  

	alert(NaN == NaN);    // false

**针对 NaN 的这两个特点，ECMAScript 定义了 isNaN() 函数**。  

这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否 "不是数值"。   
isNaN() 在接收到一个值之后，会尝试将这个值转换为数值。  
某些不是数值的值会直接转换为数值，例如字符串 "10" 或 Boolean 值。  
而任何不能被转换为数值的值都会导致这个函数返回 true 。请看下面的例子：  

	alert(isNaN(NaN));    // true
    alert(isNaN(10));     // false (10是一个数值)
    alert(isNaN("10"));   // false (可以被转换成数值 10)
    alert(isNaN("blue")); // true(不能转换成数值)
    alert(isNaN(true));   // false (可以被转换成数值 1)

这个例子测试了5个不同的值。  
测试的第一个值是 NaN 本身，结果当然会返回 true 。  

然后分别测试了数值 10 和 字符串 "10"，结果这两个测试都返回了 false，  
因为前者本身就是数值，而后者可以被转换成数值。  

但是，字符串 "blue" 不能被转换成数值，因此函数返回了 true 。  

**由于 Boolean 值 true 可以被转换成数值 1** ，因此函数返回 false 。

尽管有点儿不可思议，但 isNaN() 确实也适用于对象。  
在基于对象调用 isNaN() 函数时，会**首先调用对象的 valueOf() 方法**，  
然后确定该方法返回的值是否可以转换为数值。  
如果不能，则基于这个返回值**再调用 toString() 方法**，再测试返回值。  
**而这个过程也是 ECMAScript 中内置函数和操作符的一般执行流程**。

#### 数值转换

有3个函数可以把非数值转换为数值:  Number()、parseInt() 和 parseFloat() 。  

第一个函数，即转型函数 Number() 可以用于**任何数据类型**，  
而另两个函数则专门用于把**字符串**转换成数值。  

这3个函数对于同样的输入会有返回**不同的结果**。

Number() 函数的转换规则如下。  

 - 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。
 - 如果是数字值，只是简单的传入和返回。    
 - 如果是 null 值，返回 0 。
 - 如果是undefined，返回 NaN 。
 - 如果是字符串，遵循下列规则：
 	* 如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即"1"会变成1，"123"会变成123，**而"011"会变成11(注意：前导的零被忽略了)**；
	* 如果字符串中包含有效的浮点格式，如 "1.1" ，则将其转换为对应的浮点数值 (同样，也会忽略前导零)；
	* 如果字符串中包含有十六进制格式，例如 "0xf"，则将其转化为相同大小的十进制整数数值；
	* 如果字符串是空的(不包含任何字符)，则将其转换为0；
	* 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 。  
 - 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString 方法，然后再次依照前面的规则转换返回的字符串值。

根据这么多的规则使用 Number() 把各种数据类型转换为数值确实有点复杂。  
下面还是给出几个具体的例子吧。

	var num1 = Number("Hello world!");   // NaN
    var num2 = Number("");            // 0
    var num3 = Number("0000011");   // 11
    var num4 = Number(true);           // 1

首先，字符串 `"Hello world!"` 会被转换为 `NaN` ，因为其中不包含任何有意义的数字值。  
空字符串会被转换为 0 。   
字符串 `"000011"` 会被转换为 `11`，因为忽略了其前导的零。   
最后 true 值被转换为 1 。

**一元加操作符的操作与 Number() 函数相同**。

由于 Number() 函数在转换字符串时**比较复杂而且不够合理**，  
因此在处理整数的时候更常用的是 `parseInt()` 函数。  
`parseInt()` 函数在转换字符串时，更多的是看其是否符合数值模式。  
**它会忽略字符串前面的空格，直至找到第一个非空格字符**。

**如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN** ：  
也就是说，用 **parseInt() 转换空字符串会返回 NaN** (Number() 对空字符串返回 0) 。

如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，  
直到解析完成所有后续字符**或者遇到了一个非数字字符**。  
例如，"1234blue"会被转换为 1234，因为 "blue" 会被完全忽略。  
类似地，"22.5" 会被转换为 22，因为小数点并不是有效的数字字符。  

如果字符串中的第一个字符是数字字符，parseInt() 也能够识别出各种整数格式 (即十进制、八进制和十六进制)。  
也就是说，如果字符串以 "0x" 开头且后跟数字字符，就会将其当作一个十六进制整数；  
如果字符串以 "0" 开头且后跟数字字符，则会将其当作一个八进制数来解析。  

为了更好地理解 parseInt() 函数的转换规则，下面给出一些例子：

	var num1 = parseInt("1234blue");  // 1234
    var num2 = parseInt("");             // NaN
    var num3 = parseInt("0xA");       // 10 (十六进制数)
    var num4 = parseInt("22.5");      // 22
    var num5 = parseInt("070");       // 56(八进制数)
    var num6 = parseInt("70");         // 70 (十进制数)
    var num7 = parseInt("0xf");        // 15(十六进制数)

在使用 parseInt() 解析像八进制字面量的字符串时，ECMAScript 3 和 5 存在分歧。例如：
     
	// ECMASCript 3 认为是 56 (八进制) ，ECMAScript 5 认为是 70 (十进制)
    var num =  parseInt("070");

为了消除在使用 parseInt() 函数时可能导致的上述困惑，  
可以为这个函数提供第二个参数：转换时使用的基数(即多少进制)。  
如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第二个参数，可以保证得到正确的结果，例如：

	var num = parseInt("0xAF", 16);     // 175

实际上，如果指定了16作为第二个参数，字符串可以不带前面的 "0x"，如下所示:

	var num1 = parseInt("AF", 16);   // 175
    var num2 = parseInt("AF");     // NaN

这个例子中的第一个转换成功了，而第二个则失败了。  
差别在于第一个转换传入了基数，明确告诉`parseInt()`要解析一个十六进制格式的字符串；  
而第二个转换发现第一个字符不是数字字符，因此就自动终止了。
     
指定基数会影响到转换的输出结果。例如：

	var num1 = parseInt("10", 2);  // 2 (按二进制解析)
    var num2 = parseInt("10", 8);  // 8 (按八进制解析)
    var num3 = parseInt("10", 10); // 10 (按十进制解析)
    var num4 = parseInt("10", 16); // 16 (按十六进制解析)

不指定基数意味着让 parseInt()决定如何解析输入的字符串，  
因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。

与parseInt()函数类似，parseFloat()也是从第一个字符(位置 0)开始解析每个字符。  
而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数数字字符为止。  
也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，  
因此它后面的字符串将被忽略。  
举例来说，"22.34.5" 将会被转换为 22.34

除了第一个小数点有效之外，`parseFloat()` 与 `parseInt()` 的第二个区别在于**它始终都会忽略前导的零**。  

`parseFloat()`可以识别前面讨论过的所有浮点数数值格式，也包括十进制整数格式。  
但十六进制格式的字符串则始终会被转换成 0 。  
由于<font color="red"> `parseFloat()` 只解析十进制值</font> ，因此它没有用第二个参数指定基数的用法。  

最后还要注意一点：如果字符串包含的是一个可解析为整数的数(没有小数点，或者小数点后都是零)，  
`parseFloat()` 会返回整数。  

以下是使用 `parseFloat()` 转换数值的几个典型示例。  

	var num1 = parseFloat("1234blue");  // 1234 (整数)
    var num2 = parseFloat(0xA);         // 0
    var num3 = parseFloat("22.5");      // 22.5
    var num4 = parseFloat("22.34.5");   //22.34
    var num5 = parseFloat("0908.5");    // 908.5
    var num6 = parseFloat("3.125e7");   // 31250000
     
     
     