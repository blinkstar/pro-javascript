### 延长作用域链

虽然执行环境的类型总共只有两种 -- 全局和局部(函数)，但还是有其他办法来延长作用域链。  

这么说是因为有些语句可以**在作用域链的前端临时增加一个变量对象**，  
该变量对象会在代码执行后被**移除**。  

在两种情况下会发生这种现象。  
具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

 - try-catch 语句的 catch 块；
 - with 语句

这两个语句都会在作用域链的前端添加一个变量对象。  

对 `with` 语句来说，会将**指定的对象**添加到作用域链中。

对 `catch` 语句来说，会**创建一个新的变量对象**，其中包含的是被抛出的错误对象的声明。  

下面看一个例子。

	function buildUrl(){
    	var qs = "?debug=true";
          
        with(location) {
        	var url = href + qs;
        }

        return url;
    } 

在此，`with` 语句接收的是 `location` 对象，  
因此其变量对象中就包含了 `location` 对象的所有属性和方法，  
而这个变量对象被添加到了作用域链的前端。  

`buildUrl()` 函数中定义了一个变量 `qs` 。  
当在 `with` 语句中引用变量 `href` 时(实际引用的是 `location.href`)，  
可以在当前执行环境的变量对象中找到。  
当引用变量 `qs` 时，引用的则是在 `buildUrl()` 中定义的那个变量，  
而该变量位于函数环境的变量对象中。  

至于 `with` 语句内部，则定义了一个名为 `url` 的变量，  
因而 `url` 就**成了函数执行环境**的一部分，所以可以作为函数的值被返回。

在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，  
即在 `catch` 语句中捕获的错误对象会被添加到执行环境的变量对象，  
而不是 `catch` 语句的变量对象中。  
换句话说，即使是在 `catch` 块的外部也可以访问到错误对象。IE9 修复了这个问题。

